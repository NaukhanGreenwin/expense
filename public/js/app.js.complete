// This file contains the missing functions that need to be appended to app.js

// Complete the renderExpenses function and add all missing functions
function renderExpenses() {
    expensesList.innerHTML = '';
    
    if (filteredExpenses.length === 0) {
        const emptyRow = document.createElement('tr');
        emptyRow.innerHTML = `
            <td colspan="7" class="text-center">No expenses found</td>
        `;
        expensesList.appendChild(emptyRow);
        return;
    }
    
    // Create each expense row
    filteredExpenses.forEach(expense => {
        const row = document.createElement('tr');
        
        // Format date
        const formattedDate = new Date(expense.date).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
        });
        
        // Format amount
        const formattedAmount = `$${parseFloat(expense.amount).toFixed(2)}`;
        
        // Format tax
        const taxDisplay = expense.tax ? `$${parseFloat(expense.tax).toFixed(2)}` : '-';
        
        // Get G/L code display
        const glCodeDisplay = getGLCodeName(expense.glCode);
        
        // Create description with split info if applicable
        let descriptionDisplay = expense.description || '';
        
        // Check if this is a split expense
        if (expense.splits && expense.splits.length > 0) {
            descriptionDisplay += '<div class="expense-split-summary">';
            
            // Calculate remaining amount for primary G/L code
            const totalSplitAmount = expense.splits.reduce((sum, split) => sum + parseFloat(split.amount || 0), 0);
            const remainingAmount = parseFloat(expense.amount) - totalSplitAmount;
            const remainingPercent = Math.round((remainingAmount / parseFloat(expense.amount)) * 100);
            
            if (remainingAmount > 0) {
                descriptionDisplay += `<div class="split-detail primary">
                    <span class="split-label">Primary (${expense.glCode}):</span>
                    <span class="split-value">$${remainingAmount.toFixed(2)} (${remainingPercent}%)</span>
                </div>`;
            }
            
            // Add each split
            expense.splits.forEach(split => {
                descriptionDisplay += `<div class="split-detail">
                    <span class="split-label">${split.glCode}:</span>
                    <span class="split-value">$${parseFloat(split.amount).toFixed(2)} (${Math.round(split.percentage)}%)</span>
                </div>`;
            });
            
            descriptionDisplay += '</div>';
        }
        
        // Create the location dropdown
        let locationSelect = `<select class="location-input" data-id="${expense.id}">
            <option value="">Select a location</option>`;
            
        // Add sorted options
        [...propertyData].sort((a, b) => a.address.localeCompare(b.address)).forEach(property => {
            const selected = expense.location === property.address ? 'selected' : '';
            locationSelect += `<option value="${property.address}" data-code="${property.code}" ${selected}>${property.address}</option>`;
        });
        
        locationSelect += `</select>`;
        
        // Use the property code from the expense if available
        const propertyCodeDisplay = expense.propertyCode || '-';
        
        // Create row HTML
        row.innerHTML = `
            <td data-label="Date">${formattedDate}</td>
            <td data-label="Merchant">
                <div class="expense-detail">
                    <div class="merchant-name">${expense.title}</div>
                    <div class="expense-description">${descriptionDisplay}</div>
                    ${expense.name ? `<div class="expense-meta">${expense.name}${expense.department ? ' - ' + expense.department : ''}</div>` : ''}
                </div>
            </td>
            <td data-label="Amount">${formattedAmount}</td>
            <td data-label="Tax">${taxDisplay}</td>
            <td data-label="G/L Code">${glCodeDisplay}</td>
            <td data-label="Location">${locationSelect}</td>
            <td data-label="Property Code">${propertyCodeDisplay}</td>
            <td data-label="Actions" class="action-cell">
                <div class="action-buttons">
                    <button class="btn-edit" data-id="${expense.id}"><i class="fas fa-edit"></i></button>
                    <button class="btn-delete" data-id="${expense.id}"><i class="fas fa-trash"></i></button>
                </div>
            </td>
        `;
        
        // Add event listeners
        const editBtn = row.querySelector('.btn-edit');
        const deleteBtn = row.querySelector('.btn-delete');
        const locationSelectEl = row.querySelector('.location-input');
        
        editBtn.addEventListener('click', () => openEditModal(expense));
        deleteBtn.addEventListener('click', () => deleteExpense(expense.id));
        
        if (locationSelectEl) {
            locationSelectEl.addEventListener('change', async function() {
                const expenseId = this.getAttribute('data-id');
                const newLocation = this.value;
                const selectedOption = this.options[this.selectedIndex];
                const propertyCode = selectedOption && selectedOption.dataset ? selectedOption.dataset.code : '';
                
                try {
                    await updateExpenseLocationAndCode(expenseId, newLocation, propertyCode);
                    const propertyCodeCell = row.querySelector('td[data-label="Property Code"]');
                    if (propertyCodeCell) {
                        propertyCodeCell.textContent = propertyCode || '-';
                    }
                    showNotification(`Updated location and property code`, 'success', 2000);
                } catch (error) {
                    console.error('Error updating expense location and property code:', error);
                    showNotification('Failed to update location and property code', 'error');
                }
            });
        }
        
        expensesList.appendChild(row);
    });
}

// Get G/L code display name
function getGLCodeName(code) {
    const codeMap = {
        '6408-000': '6408-000 (Office & General)',
        '6402-000': '6402-000 (Membership)',
        '6404-000': '6404-000 (Subscriptions)',
        '7335-000': '7335-000 (Education)',
        '6026-000': '6026-000 (Mileage/ETR)',
        '6010-000': '6010-000 (Food & Ent.)',
        '6011-000': '6011-000 (Social)',
        '6012-000': '6012-000 (Travel)'
    };
    return codeMap[code] || code;
}

// Delete expense
async function deleteExpense(expenseId) {
    if (!confirm('Are you sure you want to delete this expense?')) {
        return;
    }
    
    try {
        // Remove from local state
        expenses = expenses.filter(e => e.id !== expenseId);
        filteredExpenses = filteredExpenses.filter(e => e.id !== expenseId);
        
        // Re-render
        renderExpenses();
        updateTotalAmount();
        
        showNotification('Expense deleted successfully', 'success');
    } catch (error) {
        console.error('Error deleting expense:', error);
        showNotification('Failed to delete expense', 'error');
    }
}

// Update total amount
function updateTotalAmount() {
    const total = filteredExpenses.reduce((sum, expense) => {
        return sum + parseFloat(expense.amount || 0);
    }, 0);
    
    expensesTotal.textContent = `$${total.toFixed(2)}`;
}

// Show notification
function showNotification(message, type = 'info', duration = 3000) {
    // Remove any existing notifications
    const existingNotification = document.querySelector('.notification');
    if (existingNotification) {
        existingNotification.remove();
    }
    
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    
    // Add icon based on type
    let icon = 'fa-info-circle';
    if (type === 'success') icon = 'fa-check-circle';
    if (type === 'error') icon = 'fa-exclamation-circle';
    if (type === 'warning') icon = 'fa-exclamation-triangle';
    
    notification.innerHTML = `
        <i class="fas ${icon}"></i>
        <span>${message}</span>
        <button class="close-btn">&times;</button>
    `;
    
    document.body.appendChild(notification);
    
    // Trigger animation
    setTimeout(() => notification.classList.add('show'), 10);
    
    // Add close button listener
    const closeBtn = notification.querySelector('.close-btn');
    closeBtn.addEventListener('click', () => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
    });
    
    // Auto-remove after duration
    if (duration > 0) {
        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => notification.remove(), 300);
        }, duration);
    }
}

// Populate location dropdown
function populateLocationDropdown() {
    const locationSelect = document.getElementById('edit-location');
    if (!locationSelect) return;
    
    // Clear existing options (except the first one)
    locationSelect.innerHTML = '<option value="">Select a location</option>';
    
    // Sort properties by address
    const sortedProperties = [...propertyData].sort((a, b) => a.address.localeCompare(b.address));
    
    // Add options
    sortedProperties.forEach(property => {
        const option = document.createElement('option');
        option.value = property.address;
        option.textContent = property.address;
        option.dataset.code = property.code;
        locationSelect.appendChild(option);
    });
    
    // Add change listener to update property code
    locationSelect.addEventListener('change', function() {
        const selectedOption = this.options[this.selectedIndex];
        const propertyCodeInput = document.getElementById('property-code');
        if (propertyCodeInput && selectedOption) {
            propertyCodeInput.value = selectedOption.dataset.code || '';
        }
    });
}

// Determine G/L code based on merchant and description
function determineGLCode(merchant, description) {
    const text = `${merchant} ${description}`.toLowerCase();
    
    // Office & General
    if (text.includes('office') || text.includes('staples') || text.includes('supplies')) {
        return '6408-000';
    }
    
    // Membership
    if (text.includes('membership') || text.includes('association')) {
        return '6402-000';
    }
    
    // Subscriptions
    if (text.includes('subscription') || text.includes('software') || text.includes('cloud') || 
        text.includes('microsoft') || text.includes('adobe') || text.includes('zoom')) {
        return '6404-000';
    }
    
    // Education
    if (text.includes('training') || text.includes('course') || text.includes('education') || 
        text.includes('certification') || text.includes('workshop')) {
        return '7335-000';
    }
    
    // Mileage/ETR
    if (text.includes('parking') || text.includes('toll') || text.includes('mileage') || 
        text.includes('transit')) {
        return '6026-000';
    }
    
    // Food & Entertainment
    if (text.includes('restaurant') || text.includes('coffee') || text.includes('lunch') || 
        text.includes('dinner') || text.includes('meal') || text.includes('starbucks') ||
        text.includes('tim hortons')) {
        return '6010-000';
    }
    
    // Travel
    if (text.includes('hotel') || text.includes('flight') || text.includes('airbnb') || 
        text.includes('taxi') || text.includes('uber') || text.includes('lyft')) {
        return '6012-000';
    }
    
    // Default to Office & General
    return '6408-000';
}

// Add split row to the split container
function addSplitRow(glCode = '', amount = '', percentage = '') {
    const splitContainer = document.getElementById('split-container');
    if (!splitContainer) return;
    
    const splitRow = document.createElement('div');
    splitRow.className = 'split-row';
    
    const splitId = Date.now() + Math.random();
    
    splitRow.innerHTML = `
        <div class="split-row-content">
            <div class="split-gl-group">
                <select class="split-gl-select">
                    <option value="">Select G/L Code</option>
                    <option value="6408-000" ${glCode === '6408-000' ? 'selected' : ''}>6408-000 (Office & General)</option>
                    <option value="6402-000" ${glCode === '6402-000' ? 'selected' : ''}>6402-000 (Membership)</option>
                    <option value="6404-000" ${glCode === '6404-000' ? 'selected' : ''}>6404-000 (Subscriptions)</option>
                    <option value="7335-000" ${glCode === '7335-000' ? 'selected' : ''}>7335-000 (Education)</option>
                    <option value="6026-000" ${glCode === '6026-000' ? 'selected' : ''}>6026-000 (Mileage/ETR)</option>
                    <option value="6010-000" ${glCode === '6010-000' ? 'selected' : ''}>6010-000 (Food & Ent.)</option>
                    <option value="6011-000" ${glCode === '6011-000' ? 'selected' : ''}>6011-000 (Social)</option>
                    <option value="6012-000" ${glCode === '6012-000' ? 'selected' : ''}>6012-000 (Travel)</option>
                    <option value="other">Other</option>
                </select>
                <input type="text" class="split-custom-gl" placeholder="Enter custom G/L code" style="display: ${glCode && !['6408-000', '6402-000', '6404-000', '7335-000', '6026-000', '6010-000', '6011-000', '6012-000'].includes(glCode) ? 'block' : 'none'};" value="${glCode && !['6408-000', '6402-000', '6404-000', '7335-000', '6026-000', '6010-000', '6011-000', '6012-000'].includes(glCode) ? glCode : ''}">
            </div>
            <div class="split-amount-inputs">
                <div class="split-dollar">
                    <span class="dollar-sign">$</span>
                    <input type="number" class="split-amount-input" placeholder="Amount" step="0.01" min="0" value="${amount}">
                </div>
                <div class="split-percent">
                    <input type="number" class="split-percent-input" placeholder="%" step="0.1" min="0" max="100" value="${percentage}">
                    <span class="percent-sign">%</span>
                </div>
            </div>
            <button type="button" class="btn-remove-split"><i class="fas fa-times"></i></button>
        </div>
    `;
    
    splitContainer.appendChild(splitRow);
    
    // Show split summary if not already visible
    const splitSummary = document.getElementById('split-summary');
    if (splitSummary) {
        splitSummary.style.display = 'block';
    }
    
    // Add event listeners
    const glSelect = splitRow.querySelector('.split-gl-select');
    const customGlInput = splitRow.querySelector('.split-custom-gl');
    const amountInput = splitRow.querySelector('.split-amount-input');
    const percentInput = splitRow.querySelector('.split-percent-input');
    const removeBtn = splitRow.querySelector('.btn-remove-split');
    
    // Show/hide custom G/L input
    glSelect.addEventListener('change', function() {
        if (this.value === 'other') {
            customGlInput.style.display = 'block';
        } else {
            customGlInput.style.display = 'none';
        }
        updateSplitTotals();
    });
    
    // Update totals when amount changes
    amountInput.addEventListener('input', function() {
        // Auto-calculate percentage
        const totalAmount = parseFloat(document.getElementById('edit-amount').value) || 0;
        const splitAmount = parseFloat(this.value) || 0;
        if (totalAmount > 0) {
            const percent = (splitAmount / totalAmount) * 100;
            percentInput.value = percent.toFixed(1);
        }
        updateSplitTotals();
    });
    
    // Update totals when percentage changes
    percentInput.addEventListener('input', function() {
        // Auto-calculate amount
        const totalAmount = parseFloat(document.getElementById('edit-amount').value) || 0;
        const percent = parseFloat(this.value) || 0;
        const splitAmount = (totalAmount * percent) / 100;
        amountInput.value = splitAmount.toFixed(2);
        updateSplitTotals();
    });
    
    // Remove split
    removeBtn.addEventListener('click', function() {
        splitRow.remove();
        updateSplitTotals();
        
        // Hide split summary if no more splits
        if (splitContainer.children.length === 0 && splitSummary) {
            splitSummary.style.display = 'none';
        }
    });
}

// Update split totals
function updateSplitTotals() {
    const totalAmount = parseFloat(document.getElementById('edit-amount').value) || 0;
    const splitContainer = document.getElementById('split-container');
    
    if (!splitContainer || splitContainer.children.length === 0) {
        return;
    }
    
    let allocatedAmount = 0;
    
    // Sum up all split amounts
    const splitRows = splitContainer.querySelectorAll('.split-row');
    splitRows.forEach(row => {
        const amountInput = row.querySelector('.split-amount-input');
        allocatedAmount += parseFloat(amountInput.value) || 0;
    });
    
    const remainingAmount = totalAmount - allocatedAmount;
    const allocatedPercent = totalAmount > 0 ? (allocatedAmount / totalAmount) * 100 : 0;
    const remainingPercent = totalAmount > 0 ? (remainingAmount / totalAmount) * 100 : 100;
    
    // Update display
    document.getElementById('split-allocated-amount').textContent = `$${allocatedAmount.toFixed(2)}`;
    document.getElementById('split-allocated-percent').textContent = `${allocatedPercent.toFixed(1)}%`;
    document.getElementById('split-remaining-amount').textContent = `$${remainingAmount.toFixed(2)}`;
    document.getElementById('split-remaining-percent').textContent = `${remainingPercent.toFixed(1)}%`;
}

// Initialize signature functionality
function initSignature() {
    signatureCanvas = document.getElementById('signature-canvas');
    if (!signatureCanvas) return;
    
    signatureCtx = signatureCanvas.getContext('2d');
    
    // Check for saved signature
    const savedSignature = localStorage.getItem('userSignature');
    if (savedSignature) {
        userSignature = savedSignature;
        displayCurrentSignature();
    }
    
    // Set up canvas
    setupCanvas();
    
    // Tab switching
    document.getElementById('draw-tab')?.addEventListener('click', () => switchTab('draw'));
    document.getElementById('upload-tab')?.addEventListener('click', () => switchTab('upload'));
    
    // Drawing events
    signatureCanvas.addEventListener('mousedown', startDrawing);
    signatureCanvas.addEventListener('mousemove', draw);
    signatureCanvas.addEventListener('mouseup', stopDrawing);
    signatureCanvas.addEventListener('mouseout', stopDrawing);
    
    // Touch events for mobile
    signatureCanvas.addEventListener('touchstart', handleTouchStart);
    signatureCanvas.addEventListener('touchmove', handleTouchMove);
    signatureCanvas.addEventListener('touchend', stopDrawing);
    
    // Buttons
    document.getElementById('clear-signature')?.addEventListener('click', clearSignature);
    document.getElementById('save-drawn-signature')?.addEventListener('click', saveDrawnSignature);
    document.getElementById('signature-upload')?.addEventListener('click', handleSignatureUpload);
    document.getElementById('save-uploaded-signature')?.addEventListener('click', saveUploadedSignature);
    document.getElementById('change-signature')?.addEventListener('click', changeSignature);
}

function setupCanvas() {
    if (!signatureCanvas) return;
    
    const rect = signatureCanvas.getBoundingClientRect();
    signatureCanvas.width = rect.width;
    signatureCanvas.height = rect.height;
    
    signatureCtx.strokeStyle = '#000';
    signatureCtx.lineWidth = 2;
    signatureCtx.lineCap = 'round';
    signatureCtx.lineJoin = 'round';
}

function switchTab(tab) {
    const drawTab = document.getElementById('draw-tab');
    const uploadTab = document.getElementById('upload-tab');
    const drawPanel = document.getElementById('draw-signature-panel');
    const uploadPanel = document.getElementById('upload-signature-panel');
    
    if (tab === 'draw') {
        drawTab.classList.add('active');
        uploadTab.classList.remove('active');
        drawPanel.classList.add('active');
        uploadPanel.classList.remove('active');
    } else {
        drawTab.classList.remove('active');
        uploadTab.classList.add('active');
        drawPanel.classList.remove('active');
        uploadPanel.classList.add('active');
    }
}

function startDrawing(e) {
    isDrawing = true;
    const rect = signatureCanvas.getBoundingClientRect();
    signatureCtx.beginPath();
    signatureCtx.moveTo(e.clientX - rect.left, e.clientY - rect.top);
}

function draw(e) {
    if (!isDrawing) return;
    const rect = signatureCanvas.getBoundingClientRect();
    signatureCtx.lineTo(e.clientX - rect.left, e.clientY - rect.top);
    signatureCtx.stroke();
}

function stopDrawing() {
    isDrawing = false;
}

function handleTouchStart(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent('mousedown', {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    signatureCanvas.dispatchEvent(mouseEvent);
}

function handleTouchMove(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent('mousemove', {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    signatureCanvas.dispatchEvent(mouseEvent);
}

function clearSignature() {
    if (!signatureCtx) return;
    signatureCtx.clearRect(0, 0, signatureCanvas.width, signatureCanvas.height);
}

function saveDrawnSignature() {
    if (!signatureCanvas) return;
    
    // Check if canvas is empty
    const imageData = signatureCtx.getImageData(0, 0, signatureCanvas.width, signatureCanvas.height);
    const isEmpty = !imageData.data.some(channel => channel !== 0);
    
    if (isEmpty) {
        showNotification('Please draw your signature first', 'warning');
        return;
    }
    
    userSignature = signatureCanvas.toDataURL('image/png');
    localStorage.setItem('userSignature', userSignature);
    displayCurrentSignature();
    showNotification('Signature saved successfully', 'success');
}

function handleSignatureUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(event) {
        const img = document.getElementById('signature-preview');
        img.src = event.target.result;
        document.getElementById('signature-preview-container').style.display = 'block';
        userSignature = event.target.result;
    };
    reader.readAsDataURL(file);
}

function saveUploadedSignature() {
    if (!userSignature) {
        showNotification('Please upload a signature image first', 'warning');
        return;
    }
    
    localStorage.setItem('userSignature', userSignature);
    displayCurrentSignature();
    showNotification('Signature saved successfully', 'success');
}

function displayCurrentSignature() {
    const container = document.getElementById('current-signature-container');
    const img = document.getElementById('current-signature');
    
    if (userSignature && container && img) {
        img.src = userSignature;
        container.style.display = 'block';
    }
}

function changeSignature() {
    const container = document.getElementById('current-signature-container');
    if (container) {
        container.style.display = 'none';
    }
    clearSignature();
}

// Reset all data
function resetAllData() {
    if (!confirm('Are you sure you want to reset all data? This will clear all expenses and your signature.')) {
        return;
    }
    
    // Clear expenses
    expenses = [];
    filteredExpenses = [];
    renderExpenses();
    updateTotalAmount();
    
    // Clear signature
    if (signatureCanvas && signatureCtx) {
        clearSignature();
        localStorage.removeItem('userSignature');
        userSignature = null;
        
        const currentContainer = document.getElementById('current-signature-container');
        if (currentContainer) {
            currentContainer.style.display = 'none';
        }
    }
    
    // Reset form inputs
    const nameInput = document.getElementById('user-name');
    const departmentInput = document.getElementById('user-department');
    const pdfFileInput = document.getElementById('pdf-file');
    
    if (nameInput) nameInput.value = '';
    if (departmentInput) departmentInput.value = '';
    if (pdfFileInput) pdfFileInput.value = '';
    
    // Clear results
    const resultsContainer = document.getElementById('pdf-results-container');
    if (resultsContainer) resultsContainer.innerHTML = '';
    
    const uploadStatus = document.getElementById('pdf-upload-status');
    if (uploadStatus) uploadStatus.innerHTML = '';
    
    currentSessionId = null;
    
    showNotification('All data has been reset', 'success');
}

// Handle Excel export
async function handleExcelExport() {
    if (expenses.length === 0) {
        showNotification('No expenses to export', 'warning');
        return;
    }
    
    try {
        loadingOverlay.classList.add('active');
        document.querySelector('.loading-overlay p').textContent = 'Generating Excel report...';
        
        const response = await fetch('/api/export-excel', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                expenses: expenses,
                signature: userSignature
            })
        });
        
        if (!response.ok) {
            throw new Error('Failed to generate Excel report');
        }
        
        // Download the file
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `Expense_Report_${new Date().toISOString().split('T')[0]}.xlsx`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        
        loadingOverlay.classList.remove('active');
        showNotification('Excel report generated successfully', 'success');
    } catch (error) {
        console.error('Error exporting to Excel:', error);
        loadingOverlay.classList.remove('active');
        showNotification('Failed to generate Excel report: ' + error.message, 'error');
    }
}

// Handle PDF export
async function handlePdfExport() {
    if (!currentSessionId) {
        showNotification('No receipts to export. Please upload PDF receipts first.', 'warning');
        return;
    }
    
    try {
        loadingOverlay.classList.add('active');
        document.querySelector('.loading-overlay p').textContent = 'Merging PDF receipts...';
        
        const response = await fetch('/api/merge-pdfs', {
            method: 'POST'
        });
        
        if (!response.ok) {
            throw new Error('Failed to merge PDFs');
        }
        
        // Download the file
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `Greenwin_Merged_PDF_${new Date().toISOString().split('T')[0]}.pdf`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        
        loadingOverlay.classList.remove('active');
        showNotification('PDF merged successfully', 'success');
    } catch (error) {
        console.error('Error exporting PDF:', error);
        loadingOverlay.classList.remove('active');
        showNotification('Failed to merge PDFs: ' + error.message, 'error');
    }
}

